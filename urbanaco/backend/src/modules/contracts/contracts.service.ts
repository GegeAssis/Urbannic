import { BadRequestException, Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma.service';
@Injectable()
export class ContractsService{
  constructor(private prisma: PrismaService){}
  async list(){ const shop = await this.prisma.tenant.findFirst({ where:{ type:'SHOP' } }); return this.prisma.rentalContract.findMany({ where:{ shopTenantId: shop?.id }, orderBy:{ createdAt:'desc' }, include:{ lines:{ include:{ bike:true, fleet:true } }, courier:true, restaurant:true } }); }
  private async resolveBadge(courierId:string){ const courier = await this.prisma.courier.findUnique({ where:{ id: courierId } }); const xp = courier?.xp ?? 0; const badges = await this.prisma.badge.findMany({ orderBy:{ minXp:'asc' } }); let current = badges[0]; for(const b of badges) if(xp>=b.minXp) current = b; return current; }
  private async enforce8020(shopId:string, newMode:'RENTAL'|'PURCHASE'){ const active = await this.prisma.rentalContract.groupBy({ by:['mode'], where:{ shopTenantId: shopId, status:'ACTIVE' }, _count:{ _all:true } }); let rental=0, purchase=0; active.forEach(a=>{ if(a.mode==='RENTAL') rental=a._count._all; if(a.mode==='PURCHASE') purchase=a._count._all; }); const total = rental + purchase + 1; const nextRental = rental + (newMode==='RENTAL'?1:0); const nextPurchase = purchase + (newMode==='PURCHASE'?1:0); const rentalPct = nextRental/total; const purchasePct = nextPurchase/total; if(purchasePct>0.20) throw new BadRequestException('Limite 20% de compra excedido'); if(rentalPct<0.80) throw new BadRequestException('Meta 80% aluguel não atendida'); }
  async createCourierContract(data:{ courierName:string; bikeId:string; mode:'RENTAL'|'PURCHASE'; priceCents:number }){ const shop = await this.prisma.tenant.findFirst({ where:{ type:'SHOP' } }); if(!shop) throw new BadRequestException('No SHOP tenant'); await this.enforce8020(shop.id, data.mode); const bike = await this.prisma.bike.findUnique({ where:{ id: data.bikeId } }); if(!bike || bike.tenantId!==shop.id) throw new BadRequestException('Bike inválida'); if(bike.status==='RENTED') throw new BadRequestException('Bike já alugada'); let user = await this.prisma.user.findFirst({ where:{ name: data.courierName } }); if(!user) user = await this.prisma.user.create({ data:{ name: data.courierName, email: `${Date.now()}@demo.local`, role:'COURIER' } }); let courier = await this.prisma.courier.findUnique({ where:{ id: user.id } }); if(!courier) courier = await this.prisma.courier.create({ data:{ id: user.id, city:'Ipatinga', user:{ connect:{ id: user.id } } } as any }); const active = await this.prisma.rentalContract.count({ where:{ courierId: courier.id, status:'ACTIVE' } }); if(active>0) throw new BadRequestException('Courier já tem 1 aluguel ativo'); const contract = await this.prisma.rentalContract.create({ data:{ shopTenantId: shop.id, courierId: courier.id, mode: data.mode, type:'BIKE', status:'ACTIVE', startAt: new Date(), lines:{ create:[{ bikeId: bike.id, isActive:true }] } }, include:{ lines:{ include:{ bike:true } } } }); await this.prisma.bike.update({ where:{ id: bike.id }, data:{ status:'RENTED' } }); await this.prisma.courier.update({ where:{ id: courier.id }, data:{ hasActiveRental:true } }); const badge = await this.resolveBadge(courier.id); const baseRate = 0.20; const effectiveRate = Math.max(0, baseRate - (badge?.discountRate??0)); const appFeeAmount = Math.round((data.priceCents||0) * effectiveRate); await this.prisma.transaction.create({ data:{ type:'RENTAL', amount:data.priceCents||0, tenantId: shop.id, courierId: courier.id, badgeCode: badge?.code, baseFeeRate: baseRate, effectiveFeeRate: effectiveRate, appFeeAmount } }); return { ...contract, fee:{ baseRate, effectiveRate, appFeeAmount, badge: badge?.code ?? 'CERIO' } }; }
  async createRestaurantContract(data:{ fleetId?:string; bikeIds?:string[]; priceCents:number }){ const shop = await this.prisma.tenant.findFirst({ where:{ type:'SHOP' } }); const rest = await this.prisma.tenant.findFirst({ where:{ type:'RESTAURANT' } }); if(!shop || !rest) throw new BadRequestException('Tenants não encontrados'); await this.enforce8020(shop.id, 'RENTAL'); let lines:any[]=[]; if(data.fleetId){ const fleet = await this.prisma.fleet.findUnique({ where:{ id: data.fleetId } }); if(!fleet || fleet.shopTenantId!==shop.id) throw new BadRequestException('Frota inválida'); lines.push({ fleetId: data.fleetId, isActive:true }); } else if(data.bikeIds?.length){ const bikes = await this.prisma.bike.findMany({ where:{ id:{ in: data.bikeIds }, tenantId: shop.id } }); if(bikes.length!==data.bikeIds.length) throw new BadRequestException('Algumas bikes inválidas'); lines = data.bikeIds.map(bikeId=>({ bikeId, isActive:true })); await this.prisma.bike.updateMany({ where:{ id:{ in: data.bikeIds } }, data:{ status:'RENTED' } }); } else { throw new BadRequestException('Informe fleetId ou bikeIds'); } const contract = await this.prisma.rentalContract.create({ data:{ shopTenantId: shop.id, restaurantTenantId: rest.id, mode:'RENTAL', type: lines[0].fleetId ? 'FLEET' : 'BIKE', status:'ACTIVE', startAt: new Date(), lines:{ create: lines } }, include:{ lines:{ include:{ bike:true, fleet:true } } } }); const baseRate=0.20, effectiveRate=0.20; const appFeeAmount = Math.round((data.priceCents||0) * effectiveRate); await this.prisma.transaction.create({ data:{ type:'RENTAL', amount:data.priceCents||0, tenantId: shop.id, baseFeeRate: baseRate, effectiveFeeRate: effectiveRate, appFeeAmount } }); return { ...contract, fee:{ baseRate, effectiveRate, appFeeAmount } }; }
  async terminate(id:string){ const c = await this.prisma.rentalContract.findUnique({ where:{ id }, include:{ lines:true } }); if(!c) throw new BadRequestException('Contrato não encontrado'); await this.prisma.rentalContract.update({ where:{ id }, data:{ status:'ENDED', endAt: new Date() } }); const bikeIds = c.lines.map(l=>l.bikeId).filter(Boolean) as string[]; if(bikeIds.length) await this.prisma.bike.updateMany({ where:{ id:{ in: bikeIds } }, data:{ status:'AVAILABLE' } }); if(c.courierId) await this.prisma.courier.update({ where:{ id: c.courierId }, data:{ hasActiveRental:false } }); await this.prisma.rentalLine.updateMany({ where:{ contractId: id }, data:{ isActive:false } }); return { ok:true }; }
}
